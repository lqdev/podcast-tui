use crate::download::DownloadManager;
use crate::playlist::{
    file_manager::{PlaylistFileError, PlaylistFileManager},
    AutoPlaylistKind, Playlist, PlaylistEpisode, PlaylistId, PlaylistType, RefreshPolicy,
};
use crate::storage::{EpisodeId, JsonStorage, PodcastId, Storage};
use chrono::Utc;
use std::sync::Arc;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum PlaylistError {
    #[error("Storage error: {0}")]
    Storage(String),
    #[error("File error: {0}")]
    File(#[from] PlaylistFileError),
    #[error("Download error: {0}")]
    Download(String),
    #[error("Playlist not found: {0}")]
    NotFound(String),
    #[error("Playlist already exists: {0}")]
    AlreadyExists(String),
    #[error("Cannot modify auto-generated playlist: {0}")]
    AutoPlaylistReadOnly(String),
    #[error("Episode not found in playlist: {0}")]
    EpisodeNotFound(String),
    #[error("Invalid playlist name")]
    InvalidPlaylistName,
    #[error("Invalid reorder index from {from_idx} to {to_idx}")]
    InvalidReorder { from_idx: usize, to_idx: usize },
}

pub struct PlaylistManager {
    storage: Arc<JsonStorage>,
    download_manager: Arc<DownloadManager<JsonStorage>>,
    file_manager: PlaylistFileManager,
}

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub struct RebuildResult {
    pub rebuilt: usize,
    pub skipped: usize,
    pub failed: usize,
}

impl PlaylistManager {
    pub fn new(
        storage: Arc<JsonStorage>,
        download_manager: Arc<DownloadManager<JsonStorage>>,
        playlists_dir: std::path::PathBuf,
    ) -> Self {
        Self {
            storage,
            download_manager,
            file_manager: PlaylistFileManager::new(playlists_dir),
        }
    }

    pub async fn create_playlist(
        &self,
        name: &str,
        description: Option<String>,
    ) -> Result<Playlist, PlaylistError> {
        let trimmed_name = name.trim();
        if trimmed_name.is_empty() {
            return Err(PlaylistError::InvalidPlaylistName);
        }
        if trimmed_name.eq_ignore_ascii_case("today") {
            return Err(PlaylistError::AlreadyExists(trimmed_name.to_string()));
        }

        if self.get_playlist_by_name(trimmed_name).await.is_ok() {
            return Err(PlaylistError::AlreadyExists(trimmed_name.to_string()));
        }

        let now = Utc::now();
        let playlist = Playlist {
            id: PlaylistId::new(),
            name: trimmed_name.to_string(),
            description,
            playlist_type: PlaylistType::User,
            episodes: Vec::new(),
            created: now,
            last_updated: now,
        };

        self.storage
            .save_playlist(&playlist)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        Ok(playlist)
    }

    pub async fn delete_playlist(&self, id: &PlaylistId) -> Result<(), PlaylistError> {
        let playlist = self.get_playlist(id).await?;
        if matches!(playlist.playlist_type, PlaylistType::AutoGenerated { .. }) {
            return Err(PlaylistError::AutoPlaylistReadOnly(playlist.name));
        }

        self.storage
            .delete_playlist(id)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        Ok(())
    }

    pub async fn add_episode_to_playlist(
        &self,
        playlist_id: &PlaylistId,
        podcast_id: &PodcastId,
        episode_id: &EpisodeId,
    ) -> Result<PlaylistEpisode, PlaylistError> {
        let mut playlist = self.get_playlist(playlist_id).await?;
        if matches!(playlist.playlist_type, PlaylistType::AutoGenerated { .. }) {
            return Err(PlaylistError::AutoPlaylistReadOnly(playlist.name));
        }

        if playlist
            .episodes
            .iter()
            .any(|ep| &ep.episode_id == episode_id)
        {
            return Err(PlaylistError::AlreadyExists(format!(
                "Episode {episode_id} already in playlist {}",
                playlist.name
            )));
        }

        let mut episode = self
            .storage
            .load_episode(podcast_id, episode_id)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        let source_path = if episode.is_downloaded() {
            episode
                .local_path
                .clone()
                .ok_or_else(|| PlaylistError::NotFound("Episode file path missing".to_string()))?
        } else {
            self.download_manager
                .download_episode(podcast_id, episode_id)
                .await
                .map_err(|e| PlaylistError::Download(e.to_string()))?;
            episode = self
                .storage
                .load_episode(podcast_id, episode_id)
                .await
                .map_err(|e| PlaylistError::Storage(e.to_string()))?;
            episode.local_path.clone().ok_or_else(|| {
                PlaylistError::NotFound("Episode download completed without local path".to_string())
            })?
        };

        let order = playlist.episodes.len() + 1;
        let filename = self
            .file_manager
            .copy_episode_to_playlist(&source_path, &playlist.name, order)
            .await?;

        let playlist_episode = PlaylistEpisode {
            podcast_id: podcast_id.clone(),
            episode_id: episode_id.clone(),
            added_at: Utc::now(),
            order,
            file_synced: true,
            filename: Some(filename),
        };

        playlist.episodes.push(playlist_episode.clone());
        playlist.last_updated = Utc::now();
        self.storage
            .save_playlist(&playlist)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        Ok(playlist_episode)
    }

    pub async fn remove_episode_from_playlist(
        &self,
        playlist_id: &PlaylistId,
        episode_id: &EpisodeId,
    ) -> Result<(), PlaylistError> {
        let mut playlist = self.get_playlist(playlist_id).await?;
        if matches!(playlist.playlist_type, PlaylistType::AutoGenerated { .. }) {
            return Err(PlaylistError::AutoPlaylistReadOnly(playlist.name));
        }

        let index = playlist
            .episodes
            .iter()
            .position(|ep| &ep.episode_id == episode_id)
            .ok_or_else(|| PlaylistError::EpisodeNotFound(episode_id.to_string()))?;

        let removed = playlist.episodes.remove(index);
        if let Some(filename) = removed.filename {
            self.file_manager
                .remove_episode_file(&playlist.name, &filename)
                .await?;
        }

        self.resequence_playlist_files(&mut playlist).await?;

        playlist.last_updated = Utc::now();
        self.storage
            .save_playlist(&playlist)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        Ok(())
    }

    pub async fn reorder_episode(
        &self,
        playlist_id: &PlaylistId,
        from_idx: usize,
        to_idx: usize,
    ) -> Result<(), PlaylistError> {
        let mut playlist = self.get_playlist(playlist_id).await?;
        if matches!(playlist.playlist_type, PlaylistType::AutoGenerated { .. }) {
            return Err(PlaylistError::AutoPlaylistReadOnly(playlist.name));
        }

        if from_idx >= playlist.episodes.len() || to_idx >= playlist.episodes.len() {
            return Err(PlaylistError::InvalidReorder { from_idx, to_idx });
        }
        if from_idx == to_idx {
            return Ok(());
        }

        let item = playlist.episodes.remove(from_idx);
        playlist.episodes.insert(to_idx, item);
        self.resequence_playlist_files(&mut playlist).await?;

        playlist.last_updated = Utc::now();
        self.storage
            .save_playlist(&playlist)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        Ok(())
    }

    pub async fn list_playlists(&self) -> Result<Vec<Playlist>, PlaylistError> {
        let ids = self
            .storage
            .list_playlists()
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        let mut playlists = Vec::with_capacity(ids.len());
        for id in ids {
            let playlist = self
                .storage
                .load_playlist(&id)
                .await
                .map_err(|e| PlaylistError::Storage(e.to_string()))?;
            playlists.push(playlist);
        }

        playlists.sort_by(|a, b| {
            let a_today = Self::is_today_playlist(a);
            let b_today = Self::is_today_playlist(b);
            match (a_today, b_today) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => a.name.to_lowercase().cmp(&b.name.to_lowercase()),
            }
        });

        Ok(playlists)
    }

    pub async fn get_playlist(&self, id: &PlaylistId) -> Result<Playlist, PlaylistError> {
        self.storage
            .load_playlist(id)
            .await
            .map_err(|e| PlaylistError::NotFound(e.to_string()))
    }

    pub async fn get_playlist_by_name(&self, name: &str) -> Result<Playlist, PlaylistError> {
        let playlists = self.list_playlists().await?;
        playlists
            .into_iter()
            .find(|playlist| playlist.name.eq_ignore_ascii_case(name))
            .ok_or_else(|| PlaylistError::NotFound(name.to_string()))
    }

    pub async fn rebuild_playlist_files(
        &self,
        playlist_id: &PlaylistId,
    ) -> Result<RebuildResult, PlaylistError> {
        let mut playlist = self.get_playlist(playlist_id).await?;
        if matches!(playlist.playlist_type, PlaylistType::AutoGenerated { .. }) {
            return Err(PlaylistError::AutoPlaylistReadOnly(playlist.name));
        }

        let mut result = RebuildResult::default();
        let audio_dir = self.file_manager.playlist_audio_dir(&playlist.name);

        for (idx, playlist_episode) in playlist.episodes.iter_mut().enumerate() {
            let order = idx + 1;
            playlist_episode.order = order;

            let existing_filename = playlist_episode.filename.clone();
            let existing_file_exists = existing_filename
                .as_ref()
                .map(|filename| audio_dir.join(filename).exists())
                .unwrap_or(false);

            let source_path = match self
                .storage
                .load_episode(&playlist_episode.podcast_id, &playlist_episode.episode_id)
                .await
            {
                Ok(episode) => episode.local_path,
                Err(_) => {
                    result.failed += 1;
                    if !existing_file_exists {
                        playlist_episode.filename = None;
                        playlist_episode.file_synced = false;
                    } else {
                        playlist_episode.file_synced = true;
                    }
                    continue;
                }
            };

            let Some(source_path) = source_path else {
                result.skipped += 1;
                if !existing_file_exists {
                    playlist_episode.filename = None;
                    playlist_episode.file_synced = false;
                } else {
                    playlist_episode.file_synced = true;
                }
                continue;
            };

            if !source_path.exists() {
                result.skipped += 1;
                if !existing_file_exists {
                    playlist_episode.filename = None;
                    playlist_episode.file_synced = false;
                } else {
                    playlist_episode.file_synced = true;
                }
                continue;
            }

            match self
                .file_manager
                .copy_episode_to_playlist(&source_path, &playlist.name, order)
                .await
            {
                Ok(filename) => {
                    playlist_episode.filename = Some(filename);
                    playlist_episode.file_synced = true;
                    result.rebuilt += 1;
                }
                Err(_) => {
                    result.failed += 1;
                    if !existing_file_exists {
                        playlist_episode.filename = None;
                        playlist_episode.file_synced = false;
                    } else {
                        playlist_episode.file_synced = true;
                    }
                }
            }
        }

        let valid_filenames: Vec<String> = playlist
            .episodes
            .iter()
            .filter_map(|episode| episode.filename.clone())
            .collect();
        let _ = self
            .file_manager
            .cleanup_orphaned_files(&playlist.name, &valid_filenames)
            .await?;

        playlist.last_updated = Utc::now();
        self.storage
            .save_playlist(&playlist)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        Ok(result)
    }

    async fn resequence_playlist_files(
        &self,
        playlist: &mut Playlist,
    ) -> Result<(), PlaylistError> {
        for (idx, episode) in playlist.episodes.iter_mut().enumerate() {
            episode.order = idx + 1;
        }

        let renamed = self
            .file_manager
            .rename_files_for_reorder(&playlist.name, &playlist.episodes)
            .await?;
        let mut renamed_iter = renamed.into_iter();
        for episode in &mut playlist.episodes {
            if episode.filename.is_some() {
                episode.filename = renamed_iter.next();
                episode.file_synced = episode.filename.is_some();
            }
        }

        let valid_filenames: Vec<String> = playlist
            .episodes
            .iter()
            .filter_map(|episode| episode.filename.clone())
            .collect();
        let _ = self
            .file_manager
            .cleanup_orphaned_files(&playlist.name, &valid_filenames)
            .await?;

        Ok(())
    }

    fn is_today_playlist(playlist: &Playlist) -> bool {
        matches!(
            playlist.playlist_type,
            PlaylistType::AutoGenerated {
                generator: AutoPlaylistKind::Today,
                ..
            }
        )
    }

    pub async fn ensure_today_playlist_exists(
        &self,
        refresh_policy: RefreshPolicy,
    ) -> Result<Playlist, PlaylistError> {
        if let Ok(existing) = self.get_playlist_by_name("Today").await {
            return Ok(existing);
        }

        let now = Utc::now();
        let today = Playlist {
            id: PlaylistId::from_name("Today"),
            name: "Today".to_string(),
            description: Some("Episodes published in the last 24 hours".to_string()),
            playlist_type: PlaylistType::AutoGenerated {
                generator: AutoPlaylistKind::Today,
                refresh_policy,
                last_refreshed: None,
            },
            episodes: Vec::new(),
            created: now,
            last_updated: now,
        };
        self.storage
            .save_playlist(&today)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;
        Ok(today)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::DownloadConfig;
    use crate::podcast::{Episode, EpisodeStatus, Podcast};
    use tempfile::TempDir;

    struct TestContext {
        _tmp: TempDir,
        storage: Arc<JsonStorage>,
        manager: PlaylistManager,
    }

    async fn create_test_context() -> TestContext {
        let tmp = TempDir::new().expect("Failed to create temp directory");
        let data_dir = tmp.path().join("data");
        let downloads_dir = tmp.path().join("downloads");

        let storage = Arc::new(JsonStorage::with_data_dir(data_dir.clone()));
        storage
            .initialize()
            .await
            .expect("Failed to initialize storage");

        let mut download_config = DownloadConfig::default();
        download_config.directory = downloads_dir.to_string_lossy().to_string();
        let download_manager = Arc::new(
            DownloadManager::new(storage.clone(), downloads_dir, download_config)
                .expect("Failed to create download manager"),
        );

        let manager = PlaylistManager::new(
            storage.clone(),
            download_manager,
            data_dir.join("Playlists"),
        );

        TestContext {
            _tmp: tmp,
            storage,
            manager,
        }
    }

    async fn seed_downloaded_episode(
        storage: &Arc<JsonStorage>,
        base: &std::path::Path,
    ) -> (PodcastId, EpisodeId, std::path::PathBuf) {
        let podcast_id = PodcastId::new();
        let mut podcast = Podcast::new(
            "Test Podcast".to_string(),
            "https://example.com/feed.xml".to_string(),
        );
        podcast.id = podcast_id.clone();
        storage
            .save_podcast(&podcast)
            .await
            .expect("Failed to save podcast");

        let episode_id = EpisodeId::new();
        let mut episode = Episode::new(
            podcast_id.clone(),
            "Downloaded Episode".to_string(),
            "https://example.com/episode.mp3".to_string(),
            Utc::now(),
        );
        episode.id = episode_id.clone();
        episode.status = EpisodeStatus::Downloaded;
        let file_path = base.join("downloads").join("episode.mp3");
        tokio::fs::create_dir_all(file_path.parent().expect("Missing parent"))
            .await
            .expect("Failed to create download dir");
        tokio::fs::write(&file_path, b"audio")
            .await
            .expect("Failed to write episode file");
        episode.local_path = Some(file_path.clone());
        storage
            .save_episode(&podcast_id, &episode)
            .await
            .expect("Failed to save episode");

        (podcast_id, episode_id, file_path)
    }

    #[tokio::test]
    async fn test_create_playlist() {
        let ctx = create_test_context().await;
        let created = ctx
            .manager
            .create_playlist("Morning Commute", None)
            .await
            .expect("Failed to create playlist");
        assert_eq!(created.name, "Morning Commute");
        assert!(matches!(created.playlist_type, PlaylistType::User));
    }

    #[tokio::test]
    async fn test_create_duplicate_name_fails() {
        let ctx = create_test_context().await;
        ctx.manager
            .create_playlist("Morning Commute", None)
            .await
            .expect("Failed to create first playlist");
        let err = ctx
            .manager
            .create_playlist("Morning Commute", None)
            .await
            .expect_err("Expected duplicate playlist error");
        assert!(matches!(err, PlaylistError::AlreadyExists(_)));
    }

    #[tokio::test]
    async fn test_add_episode_to_playlist() {
        let ctx = create_test_context().await;
        let playlist = ctx
            .manager
            .create_playlist("Workout", None)
            .await
            .expect("Failed to create playlist");
        let (podcast_id, episode_id, _) =
            seed_downloaded_episode(&ctx.storage, ctx._tmp.path()).await;

        let added = ctx
            .manager
            .add_episode_to_playlist(&playlist.id, &podcast_id, &episode_id)
            .await
            .expect("Failed to add episode");

        assert_eq!(added.order, 1);
        assert!(added.filename.is_some());
    }

    #[tokio::test]
    async fn test_remove_episode_from_playlist() {
        let ctx = create_test_context().await;
        let playlist = ctx
            .manager
            .create_playlist("Cleanup", None)
            .await
            .expect("Failed to create playlist");
        let (podcast_id, episode_id, _) =
            seed_downloaded_episode(&ctx.storage, ctx._tmp.path()).await;

        ctx.manager
            .add_episode_to_playlist(&playlist.id, &podcast_id, &episode_id)
            .await
            .expect("Failed to add episode");
        ctx.manager
            .remove_episode_from_playlist(&playlist.id, &episode_id)
            .await
            .expect("Failed to remove episode");

        let loaded = ctx
            .manager
            .get_playlist(&playlist.id)
            .await
            .expect("Failed to reload playlist");
        assert!(loaded.episodes.is_empty());
    }

    #[tokio::test]
    async fn test_reorder_episode() {
        let ctx = create_test_context().await;
        let playlist = ctx
            .manager
            .create_playlist("Reorder", None)
            .await
            .expect("Failed to create playlist");

        let (podcast_id, episode1_id, _) =
            seed_downloaded_episode(&ctx.storage, ctx._tmp.path()).await;
        let mut second = Episode::new(
            podcast_id.clone(),
            "Downloaded Episode 2".to_string(),
            "https://example.com/episode2.mp3".to_string(),
            Utc::now(),
        );
        second.id = EpisodeId::new();
        second.status = EpisodeStatus::Downloaded;
        let second_path = ctx._tmp.path().join("downloads").join("episode2.mp3");
        tokio::fs::write(&second_path, b"audio2")
            .await
            .expect("Failed to write second file");
        second.local_path = Some(second_path);
        ctx.storage
            .save_episode(&podcast_id, &second)
            .await
            .expect("Failed to save second episode");

        ctx.manager
            .add_episode_to_playlist(&playlist.id, &podcast_id, &episode1_id)
            .await
            .expect("Failed to add first episode");
        ctx.manager
            .add_episode_to_playlist(&playlist.id, &podcast_id, &second.id)
            .await
            .expect("Failed to add second episode");
        ctx.manager
            .reorder_episode(&playlist.id, 0, 1)
            .await
            .expect("Failed to reorder");

        let loaded = ctx
            .manager
            .get_playlist(&playlist.id)
            .await
            .expect("Failed to load playlist");
        assert_eq!(loaded.episodes[0].episode_id, second.id);
        assert_eq!(loaded.episodes[0].order, 1);
        assert_eq!(loaded.episodes[1].order, 2);
    }

    #[tokio::test]
    async fn test_delete_playlist() {
        let ctx = create_test_context().await;
        let playlist = ctx
            .manager
            .create_playlist("Delete Playlist", None)
            .await
            .expect("Failed to create playlist");
        ctx.manager
            .delete_playlist(&playlist.id)
            .await
            .expect("Failed to delete playlist");
        let missing = ctx.manager.get_playlist(&playlist.id).await;
        assert!(missing.is_err());
    }

    #[tokio::test]
    async fn test_rebuild_playlist_files_uses_download_filename_stem() {
        let ctx = create_test_context().await;
        let playlist = ctx
            .manager
            .create_playlist("Rebuild", None)
            .await
            .expect("Failed to create playlist");
        let (podcast_id, episode_id, source_path) =
            seed_downloaded_episode(&ctx.storage, ctx._tmp.path()).await;

        ctx.manager
            .add_episode_to_playlist(&playlist.id, &podcast_id, &episode_id)
            .await
            .expect("Failed to add episode");

        let mut loaded = ctx
            .manager
            .get_playlist(&playlist.id)
            .await
            .expect("Failed to load playlist");
        let audio_dir = ctx.manager.file_manager.playlist_audio_dir(&loaded.name);
        let current_filename = loaded.episodes[0]
            .filename
            .clone()
            .expect("Expected filename");
        let legacy_filename = "001-Legacy Name.mp3".to_string();
        tokio::fs::rename(
            audio_dir.join(&current_filename),
            audio_dir.join(&legacy_filename),
        )
        .await
        .expect("Failed to rename to legacy filename");

        loaded.episodes[0].filename = Some(legacy_filename.clone());
        ctx.storage
            .save_playlist(&loaded)
            .await
            .expect("Failed to save legacy playlist");

        let result = ctx
            .manager
            .rebuild_playlist_files(&playlist.id)
            .await
            .expect("Failed to rebuild playlist files");
        assert_eq!(result.rebuilt, 1);
        assert_eq!(result.skipped, 0);
        assert_eq!(result.failed, 0);

        let rebuilt = ctx
            .manager
            .get_playlist(&playlist.id)
            .await
            .expect("Failed to reload rebuilt playlist");
        let expected_stem = source_path
            .file_stem()
            .and_then(|s| s.to_str())
            .expect("Source file stem should exist");
        let expected_filename = format!("001-{}.mp3", expected_stem);
        assert_eq!(
            rebuilt.episodes[0].filename.as_deref(),
            Some(expected_filename.as_str())
        );
        assert!(audio_dir.join(expected_filename).exists());
        assert!(!audio_dir.join(legacy_filename).exists());
    }

    #[tokio::test]
    async fn test_list_playlists_sorting() {
        let ctx = create_test_context().await;
        ctx.manager
            .create_playlist("Zoo", None)
            .await
            .expect("Failed to create Zoo");
        ctx.manager
            .create_playlist("Alpha", None)
            .await
            .expect("Failed to create Alpha");
        ctx.manager
            .ensure_today_playlist_exists(RefreshPolicy::Daily)
            .await
            .expect("Failed to create Today");

        let playlists = ctx
            .manager
            .list_playlists()
            .await
            .expect("Failed to list playlists");
        assert_eq!(playlists[0].name, "Today");
        assert_eq!(playlists[1].name, "Alpha");
        assert_eq!(playlists[2].name, "Zoo");
    }
}
