use crate::download::DownloadManager;
use crate::playlist::{
    file_manager::PlaylistFileManager, manager::PlaylistError, AutoPlaylistKind, Playlist,
    PlaylistEpisode, PlaylistId, PlaylistType, RefreshPolicy,
};
use crate::storage::{JsonStorage, Storage};
use chrono::{Duration, Utc};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;

#[derive(Debug, Clone)]
pub struct TodayRefreshResult {
    pub playlist: Playlist,
    pub added: usize,
    pub removed: usize,
}

pub struct TodayGenerator {
    storage: Arc<JsonStorage>,
    download_manager: Arc<DownloadManager<JsonStorage>>,
    file_manager: PlaylistFileManager,
}

impl TodayGenerator {
    pub fn new(
        storage: Arc<JsonStorage>,
        download_manager: Arc<DownloadManager<JsonStorage>>,
        playlists_dir: std::path::PathBuf,
    ) -> Self {
        Self {
            storage,
            download_manager,
            file_manager: PlaylistFileManager::new(playlists_dir),
        }
    }

    pub fn should_refresh(playlist: &Playlist, policy: &RefreshPolicy) -> bool {
        match policy {
            RefreshPolicy::OnLaunch => true,
            RefreshPolicy::Manual => false,
            RefreshPolicy::Daily => match &playlist.playlist_type {
                PlaylistType::AutoGenerated { last_refreshed, .. } => last_refreshed
                    .map(|dt| dt.date_naive() != Utc::now().date_naive())
                    .unwrap_or(true),
                _ => true,
            },
        }
    }

    pub async fn ensure_today_playlist_exists(
        &self,
        refresh_policy: RefreshPolicy,
    ) -> Result<Playlist, PlaylistError> {
        let existing_ids = self
            .storage
            .list_playlists()
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        for id in existing_ids {
            let playlist = self
                .storage
                .load_playlist(&id)
                .await
                .map_err(|e| PlaylistError::Storage(e.to_string()))?;
            if matches!(
                playlist.playlist_type,
                PlaylistType::AutoGenerated {
                    generator: AutoPlaylistKind::Today,
                    ..
                }
            ) {
                return Ok(playlist);
            }
        }

        let now = Utc::now();
        let playlist = Playlist {
            id: PlaylistId::from_name("Today"),
            name: "Today".to_string(),
            description: Some("Episodes published in the last 24 hours".to_string()),
            playlist_type: PlaylistType::AutoGenerated {
                generator: AutoPlaylistKind::Today,
                refresh_policy,
                last_refreshed: None,
            },
            episodes: Vec::new(),
            created: now,
            last_updated: now,
        };
        self.storage
            .save_playlist(&playlist)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;
        Ok(playlist)
    }

    pub async fn refresh(&self) -> Result<TodayRefreshResult, PlaylistError> {
        let mut playlist = self
            .ensure_today_playlist_exists(RefreshPolicy::Daily)
            .await?;
        let cutoff = Utc::now() - Duration::hours(24);

        let podcast_ids = self
            .storage
            .list_podcasts()
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        let mut eligible = Vec::new();
        for podcast_id in podcast_ids {
            let episodes = self
                .storage
                .load_episodes(&podcast_id)
                .await
                .map_err(|e| PlaylistError::Storage(e.to_string()))?;
            for episode in episodes {
                if episode.published >= cutoff {
                    eligible.push((podcast_id.clone(), episode));
                }
            }
        }
        eligible.sort_by(|a, b| b.1.published.cmp(&a.1.published));

        let published_map: HashMap<_, _> = eligible
            .iter()
            .map(|(_, episode)| (episode.id.clone(), episode.published))
            .collect();
        let eligible_set: HashSet<_> = eligible
            .iter()
            .map(|(_, episode)| episode.id.clone())
            .collect();

        let mut removed = 0usize;
        let mut retained = Vec::new();
        for entry in playlist.episodes.drain(..) {
            if eligible_set.contains(&entry.episode_id) {
                retained.push(entry);
                continue;
            }
            if let Some(filename) = &entry.filename {
                let _ = self
                    .file_manager
                    .remove_episode_file(&playlist.name, filename)
                    .await;
            }
            removed += 1;
        }
        playlist.episodes = retained;

        let existing_ids: HashSet<_> = playlist
            .episodes
            .iter()
            .map(|entry| entry.episode_id.clone())
            .collect();

        let mut added = 0usize;
        for (podcast_id, mut episode) in eligible {
            if existing_ids.contains(&episode.id) {
                continue;
            }

            let source_path = if episode.is_downloaded() {
                episode.local_path.clone()
            } else {
                if self
                    .download_manager
                    .download_episode(&podcast_id, &episode.id)
                    .await
                    .is_err()
                {
                    continue;
                }
                episode = self
                    .storage
                    .load_episode(&podcast_id, &episode.id)
                    .await
                    .map_err(|e| PlaylistError::Storage(e.to_string()))?;
                episode.local_path.clone()
            };

            let Some(source_path) = source_path else {
                continue;
            };

            let filename = match self
                .file_manager
                .copy_episode_to_playlist(
                    &source_path,
                    &playlist.name,
                    playlist.episodes.len() + 1,
                    &episode.title,
                )
                .await
            {
                Ok(name) => name,
                Err(_) => continue,
            };

            playlist.episodes.push(PlaylistEpisode {
                podcast_id: podcast_id.clone(),
                episode_id: episode.id.clone(),
                added_at: Utc::now(),
                order: playlist.episodes.len() + 1,
                file_synced: true,
                filename: Some(filename),
            });
            added += 1;
        }

        playlist.episodes.sort_by(|a, b| {
            let a_pub = published_map.get(&a.episode_id);
            let b_pub = published_map.get(&b.episode_id);
            b_pub.cmp(&a_pub)
        });
        for (idx, episode) in playlist.episodes.iter_mut().enumerate() {
            episode.order = idx + 1;
        }

        let renamed = self
            .file_manager
            .rename_files_for_reorder(&playlist.name, &playlist.episodes)
            .await
            .map_err(PlaylistError::File)?;
        let mut renamed_iter = renamed.into_iter();
        for episode in &mut playlist.episodes {
            if episode.filename.is_some() {
                episode.filename = renamed_iter.next();
            }
        }

        let valid_filenames: Vec<String> = playlist
            .episodes
            .iter()
            .filter_map(|entry| entry.filename.clone())
            .collect();
        let _ = self
            .file_manager
            .cleanup_orphaned_files(&playlist.name, &valid_filenames)
            .await;

        let now = Utc::now();
        if let PlaylistType::AutoGenerated {
            generator,
            refresh_policy,
            ..
        } = &playlist.playlist_type
        {
            playlist.playlist_type = PlaylistType::AutoGenerated {
                generator: generator.clone(),
                refresh_policy: refresh_policy.clone(),
                last_refreshed: Some(now),
            };
        }
        playlist.last_updated = now;

        self.storage
            .save_playlist(&playlist)
            .await
            .map_err(|e| PlaylistError::Storage(e.to_string()))?;

        Ok(TodayRefreshResult {
            playlist,
            added,
            removed,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::DownloadConfig;
    use crate::podcast::{Episode, EpisodeStatus, Podcast};
    use crate::storage::{EpisodeId, PodcastId};
    use tempfile::TempDir;

    struct TestContext {
        tmp: TempDir,
        storage: Arc<JsonStorage>,
        generator: TodayGenerator,
    }

    async fn create_context() -> TestContext {
        let tmp = TempDir::new().expect("Failed to create temp dir");
        let data_dir = tmp.path().join("data");
        let downloads_dir = tmp.path().join("downloads");
        let storage = Arc::new(JsonStorage::with_data_dir(data_dir.clone()));
        storage.initialize().await.expect("Failed to init storage");

        let mut download_config = DownloadConfig::default();
        download_config.directory = downloads_dir.to_string_lossy().to_string();
        let download_manager = Arc::new(
            DownloadManager::new(storage.clone(), downloads_dir, download_config)
                .expect("Failed to create download manager"),
        );
        let generator = TodayGenerator::new(
            storage.clone(),
            download_manager,
            data_dir.join("playlists"),
        );

        TestContext {
            tmp,
            storage,
            generator,
        }
    }

    async fn seed_episode(
        storage: &Arc<JsonStorage>,
        tmp: &std::path::Path,
        title: &str,
        published: chrono::DateTime<Utc>,
        downloadable: bool,
    ) -> (PodcastId, EpisodeId) {
        let podcast_id = PodcastId::new();
        let mut podcast = Podcast::new(
            "Generator Podcast".to_string(),
            "https://example.com/feed.xml".to_string(),
        );
        podcast.id = podcast_id.clone();
        storage
            .save_podcast(&podcast)
            .await
            .expect("Failed to save podcast");

        let episode_id = EpisodeId::new();
        let mut episode = Episode::new(
            podcast_id.clone(),
            title.to_string(),
            if downloadable {
                "https://example.com/ep.mp3".to_string()
            } else {
                "".to_string()
            },
            published,
        );
        episode.id = episode_id.clone();

        if downloadable {
            let file = tmp.join(format!("{title}.mp3"));
            tokio::fs::write(&file, b"audio")
                .await
                .expect("Failed to write episode file");
            episode.status = EpisodeStatus::Downloaded;
            episode.local_path = Some(file);
        }

        storage
            .save_episode(&podcast_id, &episode)
            .await
            .expect("Failed to save episode");
        (podcast_id, episode_id)
    }

    #[test]
    fn test_should_refresh_daily() {
        let playlist = Playlist {
            id: PlaylistId::from_name("Today"),
            name: "Today".to_string(),
            description: None,
            playlist_type: PlaylistType::AutoGenerated {
                generator: AutoPlaylistKind::Today,
                refresh_policy: RefreshPolicy::Daily,
                last_refreshed: Some(Utc::now() - Duration::days(1)),
            },
            episodes: Vec::new(),
            created: Utc::now(),
            last_updated: Utc::now(),
        };
        assert!(TodayGenerator::should_refresh(
            &playlist,
            &RefreshPolicy::Daily
        ));
    }

    #[test]
    fn test_should_refresh_on_launch() {
        let playlist = Playlist {
            id: PlaylistId::from_name("Today"),
            name: "Today".to_string(),
            description: None,
            playlist_type: PlaylistType::AutoGenerated {
                generator: AutoPlaylistKind::Today,
                refresh_policy: RefreshPolicy::OnLaunch,
                last_refreshed: Some(Utc::now()),
            },
            episodes: Vec::new(),
            created: Utc::now(),
            last_updated: Utc::now(),
        };
        assert!(TodayGenerator::should_refresh(
            &playlist,
            &RefreshPolicy::OnLaunch
        ));
    }

    #[tokio::test]
    async fn test_refresh_adds_new_episodes() {
        let ctx = create_context().await;
        let (_podcast_id, episode_id) = seed_episode(
            &ctx.storage,
            ctx.tmp.path(),
            "new-episode",
            Utc::now() - Duration::hours(2),
            true,
        )
        .await;

        let result = ctx.generator.refresh().await.expect("Refresh failed");
        assert_eq!(result.added, 1);
        assert!(result
            .playlist
            .episodes
            .iter()
            .any(|e| e.episode_id == episode_id));
    }

    #[tokio::test]
    async fn test_refresh_removes_old_episodes() {
        let ctx = create_context().await;
        let (_podcast_id, episode_id) = seed_episode(
            &ctx.storage,
            ctx.tmp.path(),
            "old-episode",
            Utc::now() - Duration::hours(30),
            true,
        )
        .await;

        let today = ctx
            .generator
            .ensure_today_playlist_exists(RefreshPolicy::Daily)
            .await
            .expect("Failed to create today playlist");
        let mut loaded = ctx
            .storage
            .load_playlist(&today.id)
            .await
            .expect("Failed to load today");
        loaded.episodes.push(PlaylistEpisode {
            podcast_id: PodcastId::new(),
            episode_id: episode_id.clone(),
            added_at: Utc::now(),
            order: 1,
            file_synced: true,
            filename: Some("001-old-episode.mp3".to_string()),
        });
        ctx.storage
            .save_playlist(&loaded)
            .await
            .expect("Failed to seed today playlist");

        let result = ctx.generator.refresh().await.expect("Refresh failed");
        assert_eq!(result.removed, 1);
        assert!(!result
            .playlist
            .episodes
            .iter()
            .any(|e| e.episode_id == episode_id));
    }

    #[tokio::test]
    async fn test_refresh_skips_download_failure() {
        let ctx = create_context().await;
        let (_podcast_id, episode_id) = seed_episode(
            &ctx.storage,
            ctx.tmp.path(),
            "broken-episode",
            Utc::now() - Duration::hours(2),
            false,
        )
        .await;

        let result = ctx.generator.refresh().await.expect("Refresh failed");
        assert_eq!(result.added, 0);
        assert!(!result
            .playlist
            .episodes
            .iter()
            .any(|e| e.episode_id == episode_id));
    }

    #[tokio::test]
    async fn test_ensure_today_exists_creates_if_missing() {
        let ctx = create_context().await;
        let today = ctx
            .generator
            .ensure_today_playlist_exists(RefreshPolicy::Daily)
            .await
            .expect("Failed to ensure today");
        assert_eq!(today.id, PlaylistId::from_name("Today"));
    }

    #[tokio::test]
    async fn test_ensure_today_exists_returns_existing() {
        let ctx = create_context().await;
        let first = ctx
            .generator
            .ensure_today_playlist_exists(RefreshPolicy::Daily)
            .await
            .expect("Failed to create today");
        let second = ctx
            .generator
            .ensure_today_playlist_exists(RefreshPolicy::OnLaunch)
            .await
            .expect("Failed to load existing today");
        assert_eq!(first.id, second.id);
    }
}
